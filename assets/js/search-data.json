{
  
    
        "post0": {
            "title": "Title",
            "content": "# setting env vars to connect to databases import os import pickle os.environ[&#39;RESERVED_DB_HOST&#39;] = &#39;reservedai-dev-encrypted.c8ziiamlix5d.us-east-1.rds.amazonaws.com&#39; os.environ[&#39;USAGE_DB_HOST&#39;] = &#39;live-cloud-usage-encrypted.c8ziiamlix5d.us-east-1.rds.amazonaws.com&#39; os.environ[&#39;PRICING_DB_HOST&#39;] = &#39;live-cloud-pricing-encrypted.c8ziiamlix5d.us-east-1.rds.amazonaws.com&#39; os.environ[&#39;USAGE_DB_USER&#39;] = &#39;dev&#39; os.environ[&#39;PRICING_DB_USER&#39;] = &#39;dev&#39; os.environ[&#39;RESERVED_DB_USER&#39;] = &#39;dev&#39; os.environ[&#39;RESERVED_DB_PASSWORD&#39;] = &#39;Xe2eLFwO#2*W&#39; os.environ[&#39;USAGE_DB_PASSWORD&#39;] = &#39;8%1aWFxY73H6&#39; os.environ[&#39;PRICING_DB_PASSWORD&#39;] = &#39;ErGK^04glBPn&#39; os.environ[&#39;RESERVED_READ_ACCESS_KEY&#39;] = &#39;AKIA6CVLNXUSV6WBUI2Y&#39; os.environ[&#39;RESERVED_READ_SECRET_KEY&#39;] = &#39;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&#39; os.environ[&#39;RESERVED_WRITE_ACCESS_KEY&#39;] = &#39;AKIA6CVLNXUSV3NPPE66&#39; os.environ[&#39;RESERVED_WRITE_SECRET_KEY&#39;] = &#39;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&#39; . On-demand . i3_specs = {&#39;instance_type&#39;: &#39;i3.16xlarge&#39;, &#39;cpu&#39;: 64, &#39;memory&#39;: 488, &#39;storage&#39;: 15.2, &#39;ondemand_price&#39;: 4.992, &#39;price_per_cpu&#39;: 0.078, &#39;price_per_mem_gb&#39;: 0.010229508196721311, &#39;price_per_storage_tb&#39;: 0.32842105263157895, &#39;No Upfront&#39;: 3.427, &#39;Partial Upfront&#39;: 3.244374429223744, &#39;All Upfront&#39;: 3.1799086757990866, &#39;NURI_savings&#39;: 0.5154246794871795, &#39;PURI_savings&#39;: 0.5500377468485345, &#39;AURI_savings&#39;: 0.5770020465011904, &#39;no_upfront_price_per_storage_tb&#39;: 0.2254605263157895, &#39;partial_upfront_price_per_storage_tb&#39;: 0.21344568613314108, &#39;all_upfront_price_per_storage_tb&#39;: 0.20920451814467678} i3en_specs = {&#39;instance_type&#39;: &#39;i3en.24xlarge&#39;, &#39;cpu&#39;: 96, &#39;memory&#39;: 768, &#39;storage&#39;: 60, &#39;ondemand_price&#39;: 10.848, &#39;price_per_cpu&#39;: 0.113, &#39;price_per_mem_gb&#39;: 0.014125, &#39;price_per_storage_tb&#39;: 0.18080000000000002, &#39;Partial Upfront&#39;: 7.036150684931506, &#39;No Upfront&#39;: 7.388, &#39;All Upfront&#39;: 6.89554794520548, &#39;NURI_savings&#39;: 0.5648967551622419, &#39;PURI_savings&#39;: 0.5971355113751162, &#39;AURI_savings&#39;: 0.6212819567354966, &#39;no_upfront_price_per_storage_tb&#39;: 0.12313333333333333, &#39;partial_upfront_price_per_storage_tb&#39;: 0.11726917808219177, &#39;all_upfront_price_per_storage_tb&#39;: 0.114925799086758} def get_price(spec, storage, cpu, memory): storage_price = storage * spec[&#39;ondemand_price&#39;] / spec[&#39;storage&#39;] cpu_price = cpu * spec[&#39;ondemand_price&#39;] / spec[&#39;cpu&#39;] mem_price = memory * spec[&#39;ondemand_price&#39;] / spec[&#39;memory&#39;] return max(mem_price, cpu_price, storage_price) storage = 150000 cpu = storage memory = storage * 10 i3_od = get_price(i3_specs, storage, cpu, memory) i3en_od = get_price(i3en_specs, storage, cpu, memory) savings = int(100 * (i3_od - i3en_od) / i3_od) i3_od, i3en_od, savings upfront = &#39;No Upfront&#39; i3_res = i3_od * i3_specs[&#39;No Upfront&#39;] / i3_specs[&#39;ondemand_price&#39;] i3_res import matplotlib.pyplot as plt plt.bar([&#39;i3&#39;, &#39;i3en&#39;], [i3_cost, i3en_cost]) . $ Upfront . Looking at reservations savings rates for these contracts . r = ReservedMarket(region, &#39;70bf728e-579f-4484-bbe2-6558aa954e66&#39;) . i3_contracts = r.pull_ec2_reserved_contract(i3_16x_specs[&#39;instance_type&#39;], tenancy, os, region=region) i3_contracts = list(filter(lambda x: x[&#39;Duration&#39;] == 31536000 and x[&#39;OfferingClass&#39;] == &#39;standard&#39;, i3_contracts)) . 60*60*24*365 . 31536000 . 94608000/31536000 . 3.0 . 94608000/3 . 31536000.0 . i3en_contracts = r.pull_ec2_reserved_contract(i3en_24x_specs[&#39;instance_type&#39;], tenancy, os, region=region) i3en_contracts = list(filter(lambda x: x[&#39;Duration&#39;] == 31536000 and x[&#39;OfferingClass&#39;] == &#39;standard&#39;, i3en_contracts)) . i3_16x_specs[&#39;ondemand_price&#39;] = r.pull_ondemand_instance_price(i3_16x_specs[&#39;instance_type&#39;], region, tenancy, os) i3en_24x_specs[&#39;ondemand_price&#39;] = r.pull_ondemand_instance_price(i3en_24x_specs[&#39;instance_type&#39;], region, tenancy, os) . for contract in i3_contracts: i3_16x_specs[contract[&#39;OfferingType&#39;]] = r.pull_reserved_instance_price(contract) for contract in i3en_contracts: i3en_24x_specs[contract[&#39;OfferingType&#39;]] = r.pull_reserved_instance_price(contract) . i3_16x_specs[&#39;no_upfront_price_per_storage_tb&#39;] = i3_16x_specs[&#39;No Upfront&#39;]/i3_16x_specs[&#39;storage&#39;] i3en_24x_specs[&#39;no_upfront_price_per_storage_tb&#39;] = i3en_24x_specs[&#39;No Upfront&#39;]/i3en_24x_specs[&#39;storage&#39;] i3_16x_specs[&#39;partial_upfront_price_per_storage_tb&#39;] = i3_16x_specs[&#39;Partial Upfront&#39;]/i3_16x_specs[&#39;storage&#39;] i3en_24x_specs[&#39;partial_upfront_price_per_storage_tb&#39;] = i3en_24x_specs[&#39;Partial Upfront&#39;]/i3en_24x_specs[&#39;storage&#39;] i3_16x_specs[&#39;all_upfront_price_per_storage_tb&#39;] = i3_16x_specs[&#39;All Upfront&#39;]/i3_16x_specs[&#39;storage&#39;] i3en_24x_specs[&#39;all_upfront_price_per_storage_tb&#39;] = i3en_24x_specs[&#39;All Upfront&#39;]/i3en_24x_specs[&#39;storage&#39;] . i3_specs = {&#39;instance_type&#39;: &#39;i3.16xlarge&#39;, &#39;cpu&#39;: 64, &#39;memory&#39;: 488, &#39;storage&#39;: 15.2, &#39;ondemand_price&#39;: 4.992, &#39;price_per_cpu&#39;: 0.078, &#39;price_per_mem_gb&#39;: 0.010229508196721311, &#39;price_per_storage_tb&#39;: 0.32842105263157895, &#39;No Upfront&#39;: 3.427, &#39;Partial Upfront&#39;: 3.244374429223744, &#39;All Upfront&#39;: 3.1799086757990866, &#39;NURI_savings&#39;: 0.5154246794871795, &#39;PURI_savings&#39;: 0.5500377468485345, &#39;AURI_savings&#39;: 0.5770020465011904, &#39;no_upfront_price_per_storage_tb&#39;: 0.2254605263157895, &#39;partial_upfront_price_per_storage_tb&#39;: 0.21344568613314108, &#39;all_upfront_price_per_storage_tb&#39;: 0.20920451814467678} i3en_specs = {&#39;instance_type&#39;: &#39;i3en.24xlarge&#39;, &#39;cpu&#39;: 96, &#39;memory&#39;: 768, &#39;storage&#39;: 60, &#39;ondemand_price&#39;: 10.848, &#39;price_per_cpu&#39;: 0.113, &#39;price_per_mem_gb&#39;: 0.014125, &#39;price_per_storage_tb&#39;: 0.18080000000000002, &#39;Partial Upfront&#39;: 7.036150684931506, &#39;No Upfront&#39;: 7.388, &#39;All Upfront&#39;: 6.89554794520548, &#39;NURI_savings&#39;: 0.5648967551622419, &#39;PURI_savings&#39;: 0.5971355113751162, &#39;AURI_savings&#39;: 0.6212819567354966, &#39;no_upfront_price_per_storage_tb&#39;: 0.12313333333333333, &#39;partial_upfront_price_per_storage_tb&#39;: 0.11726917808219177, &#39;all_upfront_price_per_storage_tb&#39;: 0.114925799086758} . i3_16x_specs . {&#39;instance_type&#39;: &#39;i3.16xlarge&#39;, &#39;cpu&#39;: 64, &#39;memory&#39;: 488, &#39;storage&#39;: 15.2, &#39;ondemand_price&#39;: 4.992, &#39;price_per_cpu&#39;: 0.078, &#39;price_per_mem_gb&#39;: 0.010229508196721311, &#39;price_per_storage_tb&#39;: 0.32842105263157895, &#39;No Upfront&#39;: 3.427, &#39;Partial Upfront&#39;: 3.244374429223744, &#39;All Upfront&#39;: 3.1799086757990866, &#39;NURI_savings&#39;: 0.5154246794871795, &#39;PURI_savings&#39;: 0.5500377468485345, &#39;AURI_savings&#39;: 0.5770020465011904, &#39;no_upfront_price_per_storage_tb&#39;: 0.2254605263157895, &#39;partial_upfront_price_per_storage_tb&#39;: 0.21344568613314108, &#39;all_upfront_price_per_storage_tb&#39;: 0.20920451814467678} . i3en_24x_specs . {&#39;instance_type&#39;: &#39;i3en.24xlarge&#39;, &#39;cpu&#39;: 96, &#39;memory&#39;: 768, &#39;storage&#39;: 60, &#39;ondemand_price&#39;: 10.848, &#39;price_per_cpu&#39;: 0.113, &#39;price_per_mem_gb&#39;: 0.014125, &#39;price_per_storage_tb&#39;: 0.18080000000000002, &#39;Partial Upfront&#39;: 7.036150684931506, &#39;No Upfront&#39;: 7.388, &#39;All Upfront&#39;: 6.89554794520548, &#39;NURI_savings&#39;: 0.5648967551622419, &#39;PURI_savings&#39;: 0.5971355113751162, &#39;AURI_savings&#39;: 0.6212819567354966, &#39;no_upfront_price_per_storage_tb&#39;: 0.12313333333333333, &#39;partial_upfront_price_per_storage_tb&#39;: 0.11726917808219177, &#39;all_upfront_price_per_storage_tb&#39;: 0.114925799086758} . import matplotlib import matplotlib.pyplot as plt import numpy as np labels = [&#39;1 Year, No Upfront&#39;, &#39;1 Year, Partial Upfront&#39;, &#39;1 Year, All Upfront&#39;, &#39;3 Year, No Upfront&#39;, &#39;3 Year, Partial Upfront&#39;, &#39;3 Year, All Upfront&#39;] i3_prices = [.23, .21, .21, .16, .15, .14] i3en_prices = [.12, .12, .11, .08, .07, .07] x = np.arange(len(labels)) # the label locations width = 0.35 # the width of the bars fig, ax = plt.subplots() rects1 = ax.bar(x - width/2, i3_prices, width, label=&#39;i3&#39;) rects2 = ax.bar(x + width/2, i3en_prices, width, label=&#39;i3en&#39;) # Add some text for labels, title and custom x-axis tick labels, etc. ax.set_ylabel(&#39;$ per TB of storage&#39;) ax.set_title(&#39;Prices for storage by contract&#39;) ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() # def autolabel(rects): # &quot;&quot;&quot;Attach a text label above each bar in *rects*, displaying its height.&quot;&quot;&quot; # for rect in rects: # height = rect.get_height() # ax.annotate(&#39;{}&#39;.format(height), # xy=(rect.get_x() + rect.get_width() / 2, height), # xytext=(0, 3), # 3 points vertical offset # textcoords=&quot;offset points&quot;, # ha=&#39;center&#39;, va=&#39;bottom&#39;) # autolabel(rects1) # autolabel(rects2) fig.tight_layout() fig.set_size_inches(12,6) fig.savefig(&#39;storage.png&#39;) plt.show() . i3_16x_specs[&#39;NURI_savings&#39;] = (i3_16x_specs[&#39;ondemand_price&#39;] - i3_16x_specs[&#39;No Upfront&#39;]) /i3_16x_specs[&#39;ondemand_price&#39;] i3en_24x_specs[&#39;NURI_savings&#39;] = (i3en_24x_specs[&#39;ondemand_price&#39;] - i3en_24x_specs[&#39;No Upfront&#39;]) /i3en_24x_specs[&#39;ondemand_price&#39;] i3_16x_specs[&#39;PURI_savings&#39;] = (i3_16x_specs[&#39;ondemand_price&#39;] - i3_16x_specs[&#39;Partial Upfront&#39;]) /i3_16x_specs[&#39;ondemand_price&#39;] i3en_24x_specs[&#39;PURI_savings&#39;] = (i3en_24x_specs[&#39;ondemand_price&#39;] - i3en_24x_specs[&#39;Partial Upfront&#39;]) /i3en_24x_specs[&#39;ondemand_price&#39;] i3_16x_specs[&#39;AURI_savings&#39;] = (i3_16x_specs[&#39;ondemand_price&#39;] - i3_16x_specs[&#39;All Upfront&#39;]) /i3_16x_specs[&#39;ondemand_price&#39;] i3en_24x_specs[&#39;AURI_savings&#39;] = (i3en_24x_specs[&#39;ondemand_price&#39;] - i3en_24x_specs[&#39;All Upfront&#39;]) /i3en_24x_specs[&#39;ondemand_price&#39;] . print(&quot;i3.16xlarge Reservation Savings Rates&quot;) print(&quot;No Upfront&quot;) print(i3_16x_specs[&#39;NURI_savings&#39;]) print(&quot;Partial Upfront&quot;) print(i3_16x_specs[&#39;PURI_savings&#39;]) print(&quot;All Upfront&quot;) print(i3_16x_specs[&#39;AURI_savings&#39;]) . i3.16xlarge Reservation Savings Rates No Upfront 0.5154246794871795 Partial Upfront 0.5500377468485345 All Upfront 0.5770020465011904 . print(&quot;i3en.24xlarge Reservation Savings Rates&quot;) print(&quot;No Upfront&quot;) print(i3en_24x_specs[&#39;NURI_savings&#39;]) print(&quot;Partial Upfront&quot;) print(i3en_24x_specs[&#39;PURI_savings&#39;]) print(&quot;All Upfront&quot;) print(i3en_24x_specs[&#39;AURI_savings&#39;]) . i3en.24xlarge Reservation Savings Rates No Upfront 0.5648967551622419 Partial Upfront 0.5971355113751162 All Upfront 0.6212819567354966 . In terms of reservations savings, there is approximately a 5% additional savings vs on demand (around a 10% relative benefit for the reservation) by reserving i3en.24xlarge instances vs i3.16xlarge instances. Now taking this together we can see the overall savings rates for a variety of workloads for partial instances . i3_puri_fraction = (i3_16x_specs[&#39;Partial Upfront&#39;] / i3_16x_specs[&#39;ondemand_price&#39;]) i3en_puri_fraction = (i3en_24x_specs[&#39;Partial Upfront&#39;] / i3en_24x_specs[&#39;ondemand_price&#39;]) . reservation_cost_fraction_benefit = i3en_puri_fraction / i3_puri_fraction . print(&quot;Savings rate by using i3en.24xlarge partial upfront rather than i3.16xlarge partial upfront reservations&quot;) print(&quot;=================================================&quot;) for vcpus, mem_gb in savings_by_switching.keys(): print(&quot;{0} vcpu and {1} GB memory per 1 TB of storage&quot;.format(vcpus, mem_gb)) switching_cost = cost_fraction_by_switching[(vcpus, mem_gb)] new_cost_fraction = switching_cost * reservation_cost_fraction_benefit print(&quot;{0} reserved savings rate&quot;.format(1 - new_cost_fraction)) print(&quot;=================================================&quot;) . Savings rate by using i3en.24xlarge partial upfront rather than i3.16xlarge partial upfront reservations ================================================= 0.025 vcpu and 1 GB memory per 1 TB of storage 0.5071096200536537 reserved savings rate ================================================= 1 vcpu and 5 GB memory per 1 TB of storage 0.5071096200536537 reserved savings rate ================================================= 1 vcpu and 10 GB memory per 1 TB of storage 0.5071096200536537 reserved savings rate ================================================= 1 vcpu and 15 GB memory per 1 TB of storage 0.4223940860003754 reserved savings rate ================================================= 1 vcpu and 20 GB memory per 1 TB of storage 0.22985878133383386 reserved savings rate ================================================= 1 vcpu and 25 GB memory per 1 TB of storage 0.03732347666729241 reserved savings rate ================================================= 1 vcpu and 30 GB memory per 1 TB of storage -0.15521182799924915 reserved savings rate ================================================= 2 vcpu and 5 GB memory per 1 TB of storage 0.3838870250670672 reserved savings rate ================================================= 2 vcpu and 10 GB memory per 1 TB of storage 0.3838870250670672 reserved savings rate ================================================= 2 vcpu and 15 GB memory per 1 TB of storage 0.3838870250670672 reserved savings rate ================================================= 2 vcpu and 20 GB memory per 1 TB of storage 0.22985878133383386 reserved savings rate ================================================= 2 vcpu and 25 GB memory per 1 TB of storage 0.03732347666729241 reserved savings rate ================================================= 2 vcpu and 30 GB memory per 1 TB of storage -0.15521182799924915 reserved savings rate ================================================= 3 vcpu and 5 GB memory per 1 TB of storage 0.07583053760060077 reserved savings rate ================================================= 3 vcpu and 10 GB memory per 1 TB of storage 0.07583053760060077 reserved savings rate ================================================= 3 vcpu and 15 GB memory per 1 TB of storage 0.07583053760060077 reserved savings rate ================================================= 3 vcpu and 20 GB memory per 1 TB of storage 0.07583053760060077 reserved savings rate ================================================= 3 vcpu and 25 GB memory per 1 TB of storage 0.03732347666729241 reserved savings rate ================================================= 3 vcpu and 30 GB memory per 1 TB of storage -0.15521182799924915 reserved savings rate ================================================= . When reserving instances rather than paying ondemand, the story looks even better in favor of i3en.24xlarge instances if the workload is the right fit, with savings rates up to 51% when comparing the 3 year reservations of i3en.24xlarge with those of i3.16xlarge . Now we will analyze different possible purchasing options for 3 year i3en.24xlarge instances comparing their savings rate vs on demand . # heuristically, we&#39;ll use the number of instances needed to handle the storage of 10000 i3.16xlarge instances number_of_instances = int((storage_tb_to_cover / i3en_24x_specs[&#39;storage&#39;])) print(&quot;Purchasing reservations to cover {0} i3en.24xlarge instances&quot;.format(number_of_instances)) . Purchasing reservations to cover 2533 i3en.24xlarge instances . ec2_instances = [] for i in range(number_of_instances): ec2_instances.append({&#39;InstanceType&#39;: &#39;i3en.24xlarge&#39;, &#39;FractionTimeInstanceUp&#39;: 1.0, &#39;ProductDescription&#39;: os, &#39;Placement&#39;: {&#39;Tenancy&#39;: tenancy, &#39;AvailabilityZone&#39;: region}, &#39;Region&#39;: region}) . Analyzing upfront capital amounts . org_id = &#39;70bf728e-579f-4484-bbe2-6558aa954e66&#39; rec = ReservedRecommender(org_id, regions=[region]) . end = datetime.utcnow() start = end - timedelta(days=7) upfront_options = rec.get_advised_contract_savings_plan_upfront_options(start, end, max_number_of_years=3, only_convertible=False, fraction_standard_ec2=1.0, ec2_instances=ec2_instances, rds_instances=[], es_instances=[], elasticache_instances=[], redshift_instances=[]) upfront_options . [{&#39;minimum_interest_rate&#39;: 0.0, &#39;average_interest&#39;: 0.0, &#39;upfront&#39;: 0.0, &#39;savings_percentage&#39;: 56.64037913496303}, {&#39;upfront&#39;: 0.0, &#39;average_interest&#39;: 0, &#39;minimum_interest_rate&#39;: 0.051450970908028366, &#39;savings_percentage&#39;: 56.64037913496303}, {&#39;upfront&#39;: 145463928.0, &#39;average_interest&#39;: 0.051037748990110085, &#39;minimum_interest_rate&#39;: 0.051037748990110085, &#39;savings_percentage&#39;: 59.72471328131533}, {&#39;upfront&#39;: 273480696.0, &#39;average_interest&#39;: 0.048298154152965664, &#39;minimum_interest_rate&#39;: 0.045185185185185224, &#39;savings_percentage&#39;: 62.12784471687176}, {&#39;upfront&#39;: 273480696.0, &#39;average_interest&#39;: 0.048298154152965664, &#39;minimum_interest_rate&#39;: 0.013955138499648252, &#39;savings_percentage&#39;: 62.12784471687176}] . import matplotlib.pyplot as plt upfront = list(map(lambda x: x[&#39;upfront&#39;] / 1000000, upfront_options)) savings = list(map(lambda x: x[&#39;savings_percentage&#39;], upfront_options)) plt.title(&#39;Savings vs $ Upfront&#39;) plt.xlabel(&#39;Upfront Dollars (Millions)&#39;) plt.ylabel(&#39;Savings Rate (%)&#39;) plt.plot(upfront, savings) plt.show() . This reservation is quite simple w.r.t. upfront capital as both partial upfront and all upfront contracts give an interest rate on upfront capital close to 5% (5.1% and 4.8% respectively with the switchoff happening once $145463928.00 or half the total cost of the reservation over its lifetime is commited upfront) . Analyzing flexibility . No upfront . end = datetime.utcnow() start = end - timedelta(days=7) flexibility_options = rec.get_contract_savings_plan_flexibility_options(start, end, max_number_of_years=3, max_upfront_cost=0.0, ec2_instances=ec2_instances, rds_instances=[], es_instances=[], elasticache_instances=[], redshift_instances=[]) . import matplotlib.pyplot as plt inflexiblity = list(map(lambda x: x[&#39;inflexiblity&#39;], flexibility_options)) savings = list(map(lambda x: x[&#39;savings_percentage&#39;], flexibility_options)) plt.title(&#39;Savings vs Fraction Reservations Inflexible&#39;) plt.xlabel(&#39;Fraction Reservations Inflexible&#39;) plt.ylabel(&#39;Savings Rate (%)&#39;) plt.plot(inflexiblity, savings) plt.show() . Partial upfront . end = datetime.utcnow() start = end - timedelta(days=7) flexibility_options = rec.get_contract_savings_plan_flexibility_options(start, end, max_number_of_years=3, max_upfront_cost=None, minimum_upfront_interest_rate=.05, ec2_instances=ec2_instances, rds_instances=[], es_instances=[], elasticache_instances=[], redshift_instances=[]) . import matplotlib.pyplot as plt inflexiblity = list(map(lambda x: x[&#39;inflexiblity&#39;], flexibility_options)) savings = list(map(lambda x: x[&#39;savings_percentage&#39;], flexibility_options)) plt.title(&#39;Savings vs Fraction Reservations Inflexible&#39;) plt.xlabel(&#39;Fraction Reservations Inflexible&#39;) plt.ylabel(&#39;Savings Rate (%)&#39;) plt.plot(inflexiblity, savings) plt.show() . All upfront . end = datetime.utcnow() start = end - timedelta(days=7) flexibility_options = rec.get_contract_savings_plan_flexibility_options(start, end, max_number_of_years=3, max_upfront_cost=None, minimum_upfront_interest_rate=.01, ec2_instances=ec2_instances, rds_instances=[], es_instances=[], elasticache_instances=[], redshift_instances=[]) . import matplotlib.pyplot as plt inflexiblity = list(map(lambda x: x[&#39;inflexiblity&#39;], flexibility_options)) savings = list(map(lambda x: x[&#39;savings_percentage&#39;], flexibility_options)) plt.title(&#39;Savings vs Fraction Reservations Inflexible&#39;) plt.xlabel(&#39;Fraction Reservations Inflexible&#39;) plt.ylabel(&#39;Savings Rate (%)&#39;) plt.plot(inflexiblity, savings) plt.show() . For all purchasing options, there is around a 6% increase in savings vs on demand moving from the most flexible option (which covers all ec2 and fargate usage across all regions) to the least flexible option (which only covers the i3en.24xlarge instances running in the specified region). It is likely some intermediate flexibility option will be the best fit, getting maximum savings on the instances that are known ahead of time while still allowing leeway for engineering changes going forward. . In Conclusion . For a storage bound workload, it is incredibly more cost efficient to use the i3en.24xlarge instances rather than the i3.16xlarge, allowing a possible 51% in additional savings due to both the more cost-efficient use of storage and the relatively cheaper reservations for the i3en.24xlarge. . There are some tradeoffs to consider when reserving this many instances for a long time and as such both the upfront capital must be set so as to ensure you get exactly the additional savings (alternatively seen as an interest rate) on it that makes it worth your while to put money down, and the variety of possibile flexibility options based on the future certainity of using those machine types .",
            "url": "https://natesolon.github.io/fastpages/2020/03/16/test.html",
            "relUrl": "/2020/03/16/test.html",
            "date": " • Mar 16, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://natesolon.github.io/fastpages/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://natesolon.github.io/fastpages/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}