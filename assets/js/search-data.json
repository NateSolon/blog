{
  
    
        "post0": {
            "title": "",
            "content": "I&#39;ve always had a sneaking suspicion that I suck at endgames. Certainly, I can remember many endgames that I&#39;ve painfully screwed up. But if there&#39;s one thing I&#39;ve learned from poker, it&#39;s that our memory of what happened over many games can differ wildly from reality when checked against hard data. . It shouldn&#39;t be too hard to check my intuition about being bad at the endgame against reality. Here&#39;s the plan: . Download my latest 1000 blitz games from lichess. | Use an engine to evaluate the position after each move. | Plot the difference of the evaluations move-by-move. This should allow me to see whether, on average, my position improved or got worse at each stage of the game. | import chess import chess.engine import matplotlib.pyplot as plt import numpy as np import pandas as pd import re import requests . Download Games . I&#39;ll take advantage of the lichess API to grab my last 1000 blitz games. If you want to use this notebook to analyze your own games, simply fill in your own lichess username. The token is a lichess personal API token. This is optional, but recommended, because otherwise downloading 1000 games is pretty slow. You could also use fewer games, of course, but more games is better because the move-by-move data is pretty noisy. . username = &#39;CheckRaiseMate&#39; token = &#39;F645u9pRLoxrEuHZ&#39; . def get_pgn(username, params={}, token=None): headers = {} if token is None else {&#39;Authorization&#39;: &#39;Bearer &#39; + token} r = requests.get(f&#39;https://lichess.org/api/games/user/{username}&#39;, params=params, headers=headers) pgn = r.text return pgn . params = dict( perfType=&#39;blitz&#39;, max=1000 ) . pgn = get_pgn(username, params=params, token=token) . with open(f&#39;{username}.pgn&#39;, &#39;w&#39;) as f: f.write(pgn) . games = pgn.split(&#39; n n n&#39;)[:-1] . len(games) . 1000 . Analyze Games . To evaluate the games I&#39;ll use the latest version of Stockfish. Fortunately, the python-chess library has an engine module that makes it easy to work with the engine in Python. . First I define a helper function to check which color I was in each game. This is important, because since the analysis is from my point-of-view, in games where I was black I&#39;ll need to flip the engine evaluation. . def get_color(username, game): wp = re.compile(&#39;White &quot;(.+?)&quot;&#39;) result = wp.search(game) white = result.group(1) bp = re.compile(&#39;Black &quot;(.+?)&quot;&#39;) result = bp.search(game) black = result.group(1) if white == username: return 0 elif black == username: return 1 else: return None . Then I go through all the games and get the engine evaluation after each move. There are a few tricks here... . I decided to only run the evaluation after my own moves. It wasn&#39;t clear to me if this would be better than evaluating after my opponent&#39;s moves as well, but it does cut the number of positions I need to evaluate in half and it takes awhile to evaluate every move in 1000 games. . Then you need to set some parameters for the engine. The first is how much time to give it to think about each position. 0.1 seconds seems like a decent balance between accuracy and speed. I don&#39;t think ultra-precise evaluations are that important when you&#39;re looking at broad trends across many games. . Then there&#39;s mate score and max score. The engine gives evaluations in centipawns (100 centipawns = 1 pawn) and you need to choose a numeric value to use for a checkmate position - presumably a very large value - which is the mate score. I also felt that differences in scores above a certain threshold aren&#39;t very meaningful. For example, a +10 and +20 position are both completely winning, but a difference of 10 in the evaluation is huge and really messes up summary statistics. For that reason, I clipped the evaluations at +/- 1000 centipawns (10 pawns). I ended up doing more to address this problem, but more on that later. . def evaluate_game(game, engine, username, time=0.1, max_score=1000): board = chess.Board() color = get_color(username, game) moves = game.split(&#39; n&#39;)[-1] moves = re.sub(&quot;[0-9]* .&quot;, &quot;&quot;, moves).split()[:-1] # remove move numbers evals = [] for i, move in enumerate(moves): board.push_san(move) if i%2 == color: # get eval only after my move info = engine.analyse(board, chess.engine.Limit(time=time)) eval = info[&#39;score&#39;].white().score(mate_score=max_score) eval = np.clip(eval, -max_score, max_score) if color == 1: eval *= -1 eval /= 100 evals.append(eval) return evals . engine_path = &quot;/usr/local/Cellar/stockfish/12/bin/stockfish&quot; engine = chess.engine.SimpleEngine.popen_uci(engine_path) all_evals = [] for i, game in enumerate(games): print(f&quot;Game {i}&quot;) evals = evaluate_game(game, engine, username) all_evals.append(evals) engine.quit() #collapse_output . Game 0 Game 1 Game 2 Game 3 Game 4 Game 5 Game 6 Game 7 Game 8 Game 9 Game 10 Game 11 Game 12 Game 13 Game 14 Game 15 Game 16 Game 17 Game 18 Game 19 Game 20 Game 21 Game 22 Game 23 Game 24 Game 25 Game 26 Game 27 Game 28 Game 29 Game 30 Game 31 Game 32 Game 33 Game 34 Game 35 Game 36 Game 37 Game 38 Game 39 Game 40 Game 41 Game 42 Game 43 Game 44 Game 45 Game 46 Game 47 Game 48 Game 49 Game 50 Game 51 Game 52 Game 53 Game 54 Game 55 Game 56 Game 57 Game 58 Game 59 Game 60 Game 61 Game 62 Game 63 Game 64 Game 65 Game 66 Game 67 Game 68 Game 69 Game 70 Game 71 Game 72 Game 73 Game 74 Game 75 Game 76 Game 77 Game 78 Game 79 Game 80 Game 81 Game 82 Game 83 Game 84 Game 85 Game 86 Game 87 Game 88 Game 89 Game 90 Game 91 Game 92 Game 93 Game 94 Game 95 Game 96 Game 97 Game 98 Game 99 Game 100 Game 101 Game 102 Game 103 Game 104 Game 105 Game 106 Game 107 Game 108 Game 109 Game 110 Game 111 Game 112 Game 113 Game 114 Game 115 Game 116 Game 117 Game 118 Game 119 Game 120 Game 121 Game 122 Game 123 Game 124 Game 125 Game 126 Game 127 Game 128 Game 129 Game 130 Game 131 Game 132 Game 133 Game 134 Game 135 Game 136 Game 137 Game 138 Game 139 Game 140 Game 141 Game 142 Game 143 Game 144 Game 145 Game 146 Game 147 Game 148 Game 149 Game 150 Game 151 Game 152 Game 153 Game 154 Game 155 Game 156 Game 157 Game 158 Game 159 Game 160 Game 161 Game 162 Game 163 Game 164 Game 165 Game 166 Game 167 Game 168 Game 169 Game 170 Game 171 Game 172 Game 173 Game 174 Game 175 Game 176 Game 177 Game 178 Game 179 Game 180 Game 181 Game 182 Game 183 Game 184 Game 185 Game 186 Game 187 Game 188 Game 189 Game 190 Game 191 Game 192 Game 193 Game 194 Game 195 Game 196 Game 197 Game 198 Game 199 Game 200 Game 201 Game 202 Game 203 Game 204 Game 205 Game 206 Game 207 Game 208 Game 209 Game 210 Game 211 Game 212 Game 213 Game 214 Game 215 Game 216 Game 217 Game 218 Game 219 Game 220 Game 221 Game 222 Game 223 Game 224 Game 225 Game 226 Game 227 Game 228 Game 229 Game 230 Game 231 Game 232 Game 233 Game 234 Game 235 Game 236 Game 237 Game 238 Game 239 Game 240 Game 241 Game 242 Game 243 Game 244 Game 245 Game 246 Game 247 Game 248 Game 249 Game 250 Game 251 Game 252 Game 253 Game 254 Game 255 Game 256 Game 257 Game 258 Game 259 Game 260 Game 261 Game 262 Game 263 Game 264 Game 265 Game 266 Game 267 Game 268 Game 269 Game 270 Game 271 Game 272 Game 273 Game 274 Game 275 Game 276 Game 277 Game 278 Game 279 Game 280 Game 281 Game 282 Game 283 Game 284 Game 285 Game 286 Game 287 Game 288 Game 289 Game 290 Game 291 Game 292 Game 293 Game 294 Game 295 Game 296 Game 297 Game 298 Game 299 Game 300 Game 301 Game 302 Game 303 Game 304 Game 305 Game 306 Game 307 Game 308 Game 309 Game 310 Game 311 Game 312 Game 313 Game 314 Game 315 Game 316 Game 317 Game 318 Game 319 Game 320 Game 321 Game 322 Game 323 Game 324 Game 325 Game 326 Game 327 Game 328 Game 329 Game 330 Game 331 Game 332 Game 333 Game 334 Game 335 Game 336 Game 337 Game 338 Game 339 Game 340 Game 341 Game 342 Game 343 Game 344 Game 345 Game 346 Game 347 Game 348 Game 349 Game 350 Game 351 Game 352 Game 353 Game 354 Game 355 Game 356 Game 357 Game 358 Game 359 Game 360 Game 361 Game 362 Game 363 Game 364 Game 365 Game 366 Game 367 Game 368 Game 369 Game 370 Game 371 Game 372 Game 373 Game 374 Game 375 Game 376 Game 377 Game 378 Game 379 Game 380 Game 381 Game 382 Game 383 Game 384 Game 385 Game 386 Game 387 Game 388 Game 389 Game 390 Game 391 Game 392 Game 393 Game 394 Game 395 Game 396 Game 397 Game 398 Game 399 Game 400 Game 401 Game 402 Game 403 Game 404 Game 405 Game 406 Game 407 Game 408 Game 409 Game 410 Game 411 Game 412 Game 413 Game 414 Game 415 Game 416 Game 417 Game 418 Game 419 Game 420 Game 421 Game 422 Game 423 Game 424 Game 425 Game 426 Game 427 Game 428 Game 429 Game 430 Game 431 Game 432 Game 433 Game 434 Game 435 Game 436 Game 437 Game 438 Game 439 Game 440 Game 441 Game 442 Game 443 Game 444 Game 445 Game 446 Game 447 Game 448 Game 449 Game 450 Game 451 Game 452 Game 453 Game 454 Game 455 Game 456 Game 457 Game 458 Game 459 Game 460 Game 461 Game 462 Game 463 Game 464 Game 465 Game 466 Game 467 Game 468 Game 469 Game 470 Game 471 Game 472 Game 473 Game 474 Game 475 Game 476 Game 477 Game 478 Game 479 Game 480 Game 481 Game 482 Game 483 Game 484 Game 485 Game 486 Game 487 Game 488 Game 489 Game 490 Game 491 Game 492 Game 493 Game 494 Game 495 Game 496 Game 497 Game 498 Game 499 Game 500 Game 501 Game 502 Game 503 Game 504 Game 505 Game 506 Game 507 Game 508 Game 509 Game 510 Game 511 Game 512 Game 513 Game 514 Game 515 Game 516 Game 517 Game 518 Game 519 Game 520 Game 521 Game 522 Game 523 Game 524 Game 525 Game 526 Game 527 Game 528 Game 529 Game 530 Game 531 Game 532 Game 533 Game 534 Game 535 Game 536 Game 537 Game 538 Game 539 Game 540 Game 541 Game 542 Game 543 Game 544 Game 545 Game 546 Game 547 Game 548 Game 549 Game 550 Game 551 Game 552 Game 553 Game 554 Game 555 Game 556 Game 557 Game 558 Game 559 Game 560 Game 561 Game 562 Game 563 Game 564 Game 565 Game 566 Game 567 Game 568 Game 569 Game 570 Game 571 Game 572 Game 573 Game 574 Game 575 Game 576 Game 577 Game 578 Game 579 Game 580 Game 581 Game 582 Game 583 Game 584 Game 585 Game 586 Game 587 Game 588 Game 589 Game 590 Game 591 Game 592 Game 593 Game 594 Game 595 Game 596 Game 597 Game 598 Game 599 Game 600 Game 601 Game 602 Game 603 Game 604 Game 605 Game 606 Game 607 Game 608 Game 609 Game 610 Game 611 Game 612 Game 613 Game 614 Game 615 Game 616 Game 617 Game 618 Game 619 Game 620 Game 621 Game 622 Game 623 Game 624 Game 625 Game 626 Game 627 Game 628 Game 629 Game 630 Game 631 Game 632 Game 633 Game 634 Game 635 Game 636 Game 637 Game 638 Game 639 Game 640 Game 641 Game 642 Game 643 Game 644 Game 645 Game 646 Game 647 Game 648 Game 649 Game 650 Game 651 Game 652 Game 653 Game 654 Game 655 Game 656 Game 657 Game 658 Game 659 Game 660 Game 661 Game 662 Game 663 Game 664 Game 665 Game 666 Game 667 Game 668 Game 669 Game 670 Game 671 Game 672 Game 673 Game 674 Game 675 Game 676 Game 677 Game 678 Game 679 Game 680 Game 681 Game 682 Game 683 Game 684 Game 685 Game 686 Game 687 Game 688 Game 689 Game 690 Game 691 Game 692 Game 693 Game 694 Game 695 Game 696 Game 697 Game 698 Game 699 Game 700 Game 701 Game 702 Game 703 Game 704 Game 705 Game 706 Game 707 Game 708 Game 709 Game 710 Game 711 Game 712 Game 713 Game 714 Game 715 Game 716 Game 717 Game 718 Game 719 Game 720 Game 721 Game 722 Game 723 Game 724 Game 725 Game 726 Game 727 Game 728 Game 729 Game 730 Game 731 Game 732 Game 733 Game 734 Game 735 Game 736 Game 737 Game 738 Game 739 Game 740 Game 741 Game 742 Game 743 Game 744 Game 745 Game 746 Game 747 Game 748 Game 749 Game 750 Game 751 Game 752 Game 753 Game 754 Game 755 Game 756 Game 757 Game 758 Game 759 Game 760 Game 761 Game 762 Game 763 Game 764 Game 765 Game 766 Game 767 Game 768 Game 769 Game 770 Game 771 Game 772 Game 773 Game 774 Game 775 Game 776 Game 777 Game 778 Game 779 Game 780 Game 781 Game 782 Game 783 Game 784 Game 785 Game 786 Game 787 Game 788 Game 789 Game 790 Game 791 Game 792 Game 793 Game 794 Game 795 Game 796 Game 797 Game 798 Game 799 Game 800 Game 801 Game 802 Game 803 Game 804 Game 805 Game 806 Game 807 Game 808 Game 809 Game 810 Game 811 Game 812 Game 813 Game 814 Game 815 Game 816 Game 817 Game 818 Game 819 Game 820 Game 821 Game 822 Game 823 Game 824 Game 825 Game 826 Game 827 Game 828 Game 829 Game 830 Game 831 Game 832 Game 833 Game 834 Game 835 Game 836 Game 837 Game 838 Game 839 Game 840 Game 841 Game 842 Game 843 Game 844 Game 845 Game 846 Game 847 Game 848 Game 849 Game 850 Game 851 Game 852 Game 853 Game 854 Game 855 Game 856 Game 857 Game 858 Game 859 Game 860 Game 861 Game 862 Game 863 Game 864 Game 865 Game 866 Game 867 Game 868 Game 869 Game 870 Game 871 Game 872 Game 873 Game 874 Game 875 Game 876 Game 877 Game 878 Game 879 Game 880 Game 881 Game 882 Game 883 Game 884 Game 885 Game 886 Game 887 Game 888 Game 889 Game 890 Game 891 Game 892 Game 893 Game 894 Game 895 Game 896 Game 897 Game 898 Game 899 Game 900 Game 901 Game 902 Game 903 Game 904 Game 905 Game 906 Game 907 Game 908 Game 909 Game 910 Game 911 Game 912 Game 913 Game 914 Game 915 Game 916 Game 917 Game 918 Game 919 Game 920 Game 921 Game 922 Game 923 Game 924 Game 925 Game 926 Game 927 Game 928 Game 929 Game 930 Game 931 Game 932 Game 933 Game 934 Game 935 Game 936 Game 937 Game 938 Game 939 Game 940 Game 941 Game 942 Game 943 Game 944 Game 945 Game 946 Game 947 Game 948 Game 949 Game 950 Game 951 Game 952 Game 953 Game 954 Game 955 Game 956 Game 957 Game 958 Game 959 Game 960 Game 961 Game 962 Game 963 Game 964 Game 965 Game 966 Game 967 Game 968 Game 969 Game 970 Game 971 Game 972 Game 973 Game 974 Game 975 Game 976 Game 977 Game 978 Game 979 Game 980 Game 981 Game 982 Game 983 Game 984 Game 985 Game 986 Game 987 Game 988 Game 989 Game 990 Game 991 Game 992 Game 993 Game 994 Game 995 Game 996 Game 997 Game 998 Game 999 . To make analysis easier, I put all the evaluations in a pandas dataframe. Each column is one game, the rows are moves, and each cell is an evaluation. . df = pd.concat([pd.Series(e) for e in all_evals], axis=1) . df.shape . (121, 1000) . df.head() . 0 1 2 3 4 5 6 7 8 9 ... 990 991 992 993 994 995 996 997 998 999 . 0 -0.27 | 0.21 | 0.26 | -0.21 | 0.15 | 0.21 | 0.17 | -0.34 | -0.22 | 0.08 | ... | 0.18 | -0.12 | -0.23 | 0.17 | -0.26 | -0.15 | 0.29 | -0.35 | 0.13 | -0.62 | . 1 -0.17 | 0.33 | 0.65 | -0.14 | 0.32 | 0.21 | 0.28 | -0.19 | -0.19 | 0.31 | ... | 0.07 | -0.26 | -0.18 | 0.12 | -0.27 | -0.33 | 0.12 | -0.23 | 0.06 | -0.90 | . 2 -0.19 | 0.67 | 0.68 | -0.01 | 0.46 | 0.29 | 0.45 | -0.33 | -0.02 | 0.31 | ... | 0.07 | -0.29 | -0.12 | 0.20 | -0.21 | -0.37 | 0.12 | -0.28 | 0.20 | -1.18 | . 3 -0.32 | 1.06 | 0.73 | -0.05 | 0.39 | 0.31 | 0.61 | -0.24 | 0.06 | 0.99 | ... | 0.22 | -0.03 | -0.19 | 0.18 | 0.00 | -0.29 | 0.42 | -0.39 | 0.86 | -0.67 | . 4 -0.67 | 0.67 | 0.92 | -0.21 | 0.41 | 0.06 | 0.34 | -0.26 | 0.37 | 1.30 | ... | 0.14 | -0.07 | -0.63 | 0.34 | 0.77 | -0.76 | 0.12 | -0.37 | 0.87 | -0.73 | . 5 rows × 1000 columns . df.to_csv(&#39;evals.csv&#39;, index=False) . First let&#39;s look at the mean across all columns. This is the average evaluation by move number across all games. . df.mean(axis=1)[:60].plot(); . It starts at 0.0 (equal position) and gradually goes up. This makes sense, because I win more games than I lose on lichess, so in general the evaluation should go up as the game goes on. Maybe I would improve at chess more quickly if I adjusted the seek parameters to force the server to pair me against higher rated opponents so I would lose more often, but that&#39;s a different story. . At any rate, what we&#39;re really interested in is the difference by move. . df.diff().mean(axis=1)[:50].plot(); . It seems quite noisy (it&#39;s not really plausible that I&#39;m great at playing move 20 but terrible at move 21, or whatever). This makes sense, as a single blunder that changes the evaluation by a large number like 10 could really impact the mean. I could try to address that by using the median. . df.diff().median(axis=1)[:50].plot(); . /Users/nate/.pyenv/versions/3.9.0b5/lib/python3.9/site-packages/numpy/lib/nanfunctions.py:993: RuntimeWarning: All-NaN slice encountered result = np.apply_along_axis(_nanmedian1d, axis, a, overwrite_input) . Hmm, still quite jagged. Since I&#39;m really interested in trends across phases of the game, not individual moves, it would make sense to apply some smoothing. One way to do that would be to use a rolling mean. . df.diff().mean(axis=1)[:60].rolling(10).mean().plot(); . The trend actually goes up as the game goes on! Maybe I&#39;m not as bad at the endgame as I thought? . But thinking about it more, if you win more often than you lose, there should be an upward trend not only in the evaluation, but also in the difference. This is the expected development as you convert a large advantage: +3 becomes +5 becomes +8, etc. While converting a big advantage is certainly better than blowing it, it&#39;s not really what I had in mind when I set out to evaluate my endgame play. It also makes the data sensitive to factors I have little control over, like when my opponent resigns. . Additionally, I was still concerned about large but meaningless differences in evaluations. For example, there isn&#39;t much difference between a +5 and +10 position in practical terms, but a difference of 5 will impact the mean quite a lot. I could adjust the clip value from 10 to 5, but that&#39;s still not ideal. I&#39;d like a +5 and +10 position to register as different, just not so different. I&#39;d also like the scaling to continue all the way down to 0. I think the difference between a +0 and +2 position is bigger than the difference between +2 and +4. Ideally, I&#39;d like something that: . Can take any number, positive or negative, as input. | Is more sensitive to differences closer to 0. | Still registers differences far from 0, but not as much. | . Is that sigmoid&#39;s music I hear??? . Why yes, sigmoid would seem to be perfect actually. It fits all our requirements and squishes the input into the range 0-1. Conveniently, this can be interpreted as expected points: 0 = certain loss, 1 = certain win. In fact, this is how AlphaZero evaluates positions, on a 0-1 scale representing expected score. . It will also handle the converting-a-win scenario very nicely. As long as we stay at a big plus score it won&#39;t really care, but if we blow it and get into a worse position, that will register as a big change. . def sigmoid(x): return 1 / (1 + np.exp(-x)) . Let&#39;s just plot the function as a quick visual reminder of what sigmoid does. . x = np.arange(-10, 10, 0.1) plt.plot(x, sigmoid(x)); . It&#39;s very sensitive to differences around 0, and very insensitive to differences far from 0, which is exactly what we want. . df_sigmoid = sigmoid(df) . Now I&#39;ll do the same plots I did with the raw evaluations. . df_sigmoid.mean(axis=1)[:50].plot(); . df_sigmoid.diff().mean(axis=1)[:50].plot(); . df_sigmoid.diff().mean(axis=1)[:50].rolling(10).mean().plot(); . Okay, this seems to show I do get weaker as the game goes on! But maybe I tortured the data until I got the result that I wanted? . Takeaways . The results were somewhat inconclusive: the raw data did not seem to show me getting weaker as the game went on, but after the sigmoid transformation they did. I&#39;m inclined to trust the sigmoid version more for the reasons discussed above, but my self-assessment of my endgame skills may have been overblown: the difference, if it exists, was not large or obvious. | When using summary statistics to compare engine evaluations across games, big-but-meaningless evaluation differences in clearly winning/clearly losing positions are a big problem. Using a sigmoid transformation is a promising way to combat this. | .",
            "url": "https://natesolon.github.io/blog/2020/12/27/2020-12-27-Examining-Performance-By-Game-Phase.html",
            "relUrl": "/2020/12/27/2020-12-27-Examining-Performance-By-Game-Phase.html",
            "date": " • Dec 27, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Chess Repertoire Explorer",
            "content": "MCO . In the hugely popular Netflix show Queen’s Gambit, the first book chess prodigy Beth Harmon receives from her mentor is MCO (Modern Chess Openings). . I don’t have my old copy of MCO - I must have lost or given it away - but I remember it well. A typical page looked like this: . . It was basically a giant catalog of opening variations: hundreds of pages, just like this. I think part of the appeal was the sense that something this dry and inscrutable must contain some really deep knowledge. . Intimidating as it was, MCO was the lightweight opening manual. Really serious players preferred ECO, the Encyclopedia of Chess Openings, which consisted of not one but five large volumes. The covers listed the title in multiple languages and the content had no explanatory text whatsoever, just a specialized set of symbols representing evaluations of positions. . The ponderous size and obscure format of these tomes obfuscated something important: On the scale that really counted, the scale of chess, even ECO was tiny. . Consider: Each side has 20 legal moves on move one. Thus, the number of possible sequences after just one complete move is 20 * 20 = 400. The number of possibilities after two full moves is on the order of 20^4 = 160,000. More actually, because many first moves increase the scope of the pieces and make more legal moves possible. And the possibilities increase exponentially from there. So as intimidating as it seems, even ECO only covers a tiny fraction of the possible variations. . Which in turn raises a question: Out of all the countless variations possible in chess, what good is it to memorize the relatively small selection of lines spelled out in these books? . There was never really a great answer to this question. I guess the reasoning was that the books covered the most important lines, as measured by chess logic and grandmaster practice. However, modern computer analysis shows that many of the lines and evaluations in the books were flawed. . This isn’t a knock on the authors, who made a heroic effort at an impossible task. Rather, it just underscores the futility of the underlying approach. It is not efficient or even possible to memorize every sequence of moves that might occur in your games. . Also, there’s the annoying fact that a chess game continues past the opening into the middlegame and endgame. Recalling the math outlined earlier, the branching nature of chess means that each move forward you nudge your repertoire increases the body of knowledge you need to memorize exponentially. . Planting a Tree . Looking at that page from MCO, it strikes me that the authors are struggling against the limitations of their format. The arrangement of the lines and how they relate to each other is confusing. It’s hardly obvious that the numbers along the left side of the page are move numbers whereas the numbers along the top are an index of different variations. It’s not easy to reason about my options in a given line by looking at this page. . Part of the problem is that this format is too beholden to a traditional chess scoresheet. When you play a tournament chess game, you write down all the moves. This is what they’re writing down during the tournament games in Queen’s Gambit. The finished scoresheet looks like this. . . Note that a scoresheet has a linear format: the moves go straight down the page in an unbroken sequence starting from move one. This is fine for a single game, but when we study chess, we’re concerned not just with what happened in one game, but what happened (or could happen) in many games. Thus, the structure of what we’re studying isn’t a line, but a series of branching paths. . This structure is called a tree and it’s very common in math and computer science. An early attempt at using a tree visualization for chess occurred in the famous book Think Like a Grandmaster by Alexander Kotov. . . This is a nice attempt to represent the tree-like structure of variations, but still suffers from some obvious problems. For example, it’s clearly not ideal for the text to be slanted at different angles, which contributes to the diagram being hard to read. . Fortunately, these days things are a lot easier. Now that we have computers and graphing libraries, we’re not limited to linear formats that are easy to write or print on a page. We can create visualizations that are rich, interactive, and adaptable. . Using a Sankey diagram to visualize your repertoire . To test these ideas in practice, I made an app that helps you prioritize which openings to study by using a chart type called a Sankey diagram to visualize your repertoire. I’d argue that there are two factors you should think about when deciding which opening to focus on: . How often the opening occurs in your games. Clearly, you don’t want to waste time on openings that hardly ever happen. . | How well you score in the opening. It makes sense to pay special attention to the openings where you’re struggling. . | So, which openings occur the most often in your games? And how do you score with your main openings? . These questions aren’t that easy to answer with the existing tools. The best way I know of to do this in ChessBase is: . Create a new database of the subset of games you’re interested in. For example, your white games from the past year. . | Select all the games in the database with Ctrl-A, then do Ctrl-Alt-Enter. (Good luck figuring that out from the documentation!) . | This takes you to a view where you can go through your repertoire move-by-move and see how you’ve scored in each line. Useful, but the only way to access the information is to toggle through one move at a time; there’s no top-level summary to let you see what’s going on in the big picture. . I wanted to create a way of visualizing your opening repertoire that would make it easy to answer these questions. The result was this app. It grabs your latest games from lichess and displays them in a way that makes it easy to see which openings occur the most often and how you’re doing in them. . . This kind of chart is known as a Sankey diagram. It’s used to visualize flows between various states, which are called nodes. In this case the nodes are positions and the flows are moves. . Nodes are color-coded white or black to show who made the last move, and move numbers are aligned vertically to facilitate comparison between lines. . The thickness of the flows represents how often that variation occurred. For example, a variation that only happened in one of your games will be a thin line, whereas a variation that happens frequently will be a thick flow. The flows are color-coded by how well you scored in that line: green represents a 100% score (you won every game), red represents a 0% score (you lost every game). . Based on the prioritization system introduced at the beginning of this article, you should focus on relatively thick, red areas, because these represent lines that happen a lot in your games and where you struggle. . You can use the app to create this diagram for the last 100 blitz games of any player on lichess. For example, here’s the chart for world champion Magnus Carlsen (DrNykterstein on lichess): . . Unsurprisingly, Magnus is doing pretty well, but in this sample he’s not scoring as well with the English (1. c4) as with 1. e4 or 1. d4. . The biggest thing that jumps out about this chart, of course, is just how many lines there are. This is both a feature and a bug. It’s a bug because it clutters the chart, making it harder to use for its intended purpose of evaluating your opening repertoire. However, it’s also a feature, because it reveals something true about chess that traditional ways of writing down moves obscure: namely, there are an insane number of possibilities. . I don’t know how many players will find this app to be a useful way of exploring their opening repertoire, but I’m confident that there’s a lot of room for tree-based techniques to improve how we visualize and think about chess. .",
            "url": "https://natesolon.github.io/blog/tree",
            "relUrl": "/tree",
            "date": " • Nov 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Poker Player to Data Scientist",
            "content": "I played poker for a living for seven years. About three years ago, I decided to quit and pursue a career in machine learning and data science. I’m now working full-time as a data scientist at reserved.ai. . This post is about the most important lessons from that journey. Since there’s already a lot of great resources out there about coding and math, I focused more on how to get a job without a standard technical background, and specific lessons from poker that carry over into data science. . People skills . In the course of playing poker a living for seven years I had to learn about various fields related to ML - statistics, probability, game theory - but I think the most relevant thing for getting a job in data science was actually just spending a lot of time sitting around a table with a diverse group of people and learning to get along with them. In poker, getting invited to the biggest games is often more important than being the best player. . I’m really grossed out by the term “networking” - it feels like reducing social interaction to something inauthentic and manipulative. Nonetheless, if you’re looking for a job, it pays to be a little strategic about forming social connections. . If I could pick just one thing that I think really helped me find a job, it would be doing informational interviews. I learned about this by reading Designing Your Life by Bill Burnett and Dave Evans. . I started reaching out to people I knew were doing interesting things in data science or machine learning and asking if they’d meet for coffee or lunch. I was kind of shocked how easy it was. Almost everyone I reached out to said yes, and often introduced me to new connections. . For example, I met a program manager at Sonos at a one-day data visualization class. From him I learned a lot about the day-to-day reality of working on data in a business setting. He introduced me to an engineer at Amazon who helped me prepare for coding interviews. . Some tips: . If you ask someone for help, remember that “No” is a valid answer. Be considerate and polite - apart from just being a good way to carry yourself in general, you may run into them again later. . | If someone doesn’t respond the first time, wait a week or so and try again. Many times people just don’t see an email or forget to respond. If they don’t respond a second time, it’s probably time to move on. . | Be respectful of other people’s time. I think 30 minutes is about what’s expected for a meeting like this. . | . Books aren’t where it’s at . A few weeks ago I was thinking about which resources I wished I knew about when I started learning about ML and I realized all my top choices are presented as videos: fast.ai, Weights &amp; Biases, and 3Blue1Brown. . Part of this may be my personal learning style - I often learn better by watching than by reading. But even so, I was surprised I couldn’t find a book I was really happy with. I’ve read, or at least looked through, a lot of the most famous introductory ML books, but I found they were outdated, or poorly organized, or the explanations didn’t make sense to me, or they assumed prior knowledge I thought many readers wouldn’t have. One way or another, I couldn’t find a book I was really happy with. . ML and poker are really similar in this regard. Cutting-edge information is passed through videos, forums, or groups of people working together. I think it’s because both fields are moving so fast: the theory completely changes every year or two. By the time you finish writing a book, it’s already out of date. . There are exceptions, of course. Play Optimal Poker is a new poker book that’s really well done. And if you’re reading this you probably know there’s a fast.ai book now. I haven’t had a chance to read it yet, but I’m very excited about it. . Keep it simple . We have a term in poker called FPS (“Fancy Play Syndrome”). This is when you reject the obvious play in favor of something fancy and complicated. It rarely works out well. . One amazing thing about poker right now is you can watch some of the best players in the world play and explain what they’re doing in real time. When I watch players like Ben Sulsky, Doug Polk, or Phil Galfond I’m often struck by how simple their thought process seems. Once you hear it, it seems obvious. What sets them apart is an ability to focus with laser-like precision on the most important factors for the current decision. . The ML version of FPS would be skipping linear regression and going straight to an RNN. The academic literature, in particular, is full of insanely complicated and hard-to-understand methodologies. In my experience so far, this is very far removed from working with data in a business context. For the most part you figure out a simple solution that works pretty well, then move on to the next urgent problem. . Dealing with failure . Maybe the biggest thing poker and ML have in common is this: you can make good choices, yet fail, over and over and over and over again. How you deal with this situation will have more to do with whether you ultimately succeed than anything else. . In poker someone can make a bad play and still beat you by hitting a lucky card. If this happens once, it’s easy enough to shrug off. But when you “run bad” for a long time - when the losing sessions extend into losing weeks or months - it’s hard to deal with, no matter how well you understand variance on a conceptual level. . Likewise, dealing with failure was what I found most challenging when I started learning about ML. Even simple things like setting up my environment and getting all the appropriate packages installed could take hours or days, where nothing I did seemed to work. I felt like an idiot and had no idea when it was going to end. . The obvious response is to persevere and tough it out. I think this is good advice, up to a point, but it needs to be balanced with a certain amount of levity. One of my poker coaches once gave me very good advice: “When you lose, the first thing you need to get back isn’t the money you lost, it’s your love of the game.” . While ML isn’t a game per se, it’s still helpful to have a playful mindset. This encourages creativity, which is important not just because it’s more fun, but because it will allow you to find better solutions more quickly. Try to see everything you do as an “experiment” where failure is normal, healthy, and productive. . I learned a lot by watching Rachel Tatman’s live coding streams. She makes a lot of mistakes, but iterates on them quickly and cheerfully. As they say in Designing Your Life, “Fail fast and fail forward.” . Conclusion . When I was doing informational interviews, one of the most common questions I asked was, “How big of a deal is it that I don’t have an academic background in this field?” What I heard back was pretty consistent: It might make it hard for me to get hired at some companies, but it wouldn’t prevent me from doing the work effectively. . For those trying to get a job in machine learning or data science, especially if you’re coming from a non-traditional background, I hope you’ve found something helpful here. .",
            "url": "https://natesolon.github.io/blog/poker-to-data-science",
            "relUrl": "/poker-to-data-science",
            "date": " • Mar 29, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Data scientist at Reserved.ai. . Former poker pro and chess master. . Interested in data, learning, and games. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://natesolon.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}